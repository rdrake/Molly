\chapter{Best of Both Worlds}
	\section{Encoding Named Tuples into Documents}
	\label{sec:named-tuples-documents}
		Recall in the extended document model (\vref{sec:extending-the-document-model}), a document \(\doc\) consists of fields \(\field_1, \field_2, \dotsc, \field_n\).  Using the extended document model, we are left with a straight forward mapping of a tuple \(\tuple\) to document \(\doc\).
		
		For tuple \(\tuple\), every attribute \(\attribute \in \attributes{\tuple}\) maps to a field \(\field\) in document \(\doc\).	Every attribute value must be analyzed into an indexable form in order to store it in a field.
		\begin{align}
			\attributes{\tuple} &\xrightarrow{analyzed} \fields{\doc} \\
			\attribute_1, \attribute_2, \dotsc, \attribute_n &\xrightarrow{analyzed} \field_1, \field_2, \dotsc, \field_n
		\end{align}
		
		We denote the document encoding of \(\tuple\) as \(\docs{\tuple}\).
		
		\begin{ex}
			Given the tuple
			\[
				\tuple = \{\text{code}: \text{``CDPS 101''}, \text{title}: \text{``Human-Mutant Relations''}, \text{subject}: \text{``CDPS''}\}
			\]
			
			produce the document encoding \(\docs{\tuple}\).
			
			\begin{table}
				\centering
				
				\begin{tabular}{ll}
					\toprule
					Field & Terms \\
					\midrule
					code & \(\{\text{cdps}, \text{101}\}\) \\
					title & \(\{\text{human}, \text{mutant}, \text{relations}\}\) \\
					subject & \(\{\text{cdps}\}\) \\
					\bottomrule
				\end{tabular}
				
				\caption{\(\docs{\tuple}\)}
			\end{table}
		\end{ex}

	
	\section{Mapping of Entity Groups to Documents}
	\label{sec:mapping-entity-groups-to-documents}
		Recall that an entity group (\vref{def:entity-group}) is a forest \(\egraph\) of tuples \(\tuple\) such that for every \((\tuple, \tuple') \in \egraph\), where \(\tuple \nequal \tuple'\), implies \(\relations{\tuple} \nequal \relations{\tuple'}\).  That is, every distinct tuple is from a distinct relation.
		
		Given the restriction
		\[
			\forall (\relation, \relation') \in \sgraph, \exists! (\relation, \relation') \models \theta
		\]
		
		we assert that if \(\tuple\) and \(\tuple'\) are in the entity group \(\egraph\), then there is a foreign key constraint between \(\tuple\) and \(\tuple'\).  We denote the vertices of \(\egraph\) as \(\text{V}(\egraph)\), and the edges of \(\egraph\) as \(\text{E}(\egraph)\).
		
		\begin{ex}
			Using the schema graph...
		\end{ex}
		
		\begin{claim}
		\label{clm:lossless}
			Given \(\text{V}(\egraph)\), we are always able to reconstruct \(\egraph\).
		\end{claim}
		
		\begin{proof}
			Given \(\text{V}(\egraph)\), we must reconstruct \(\text{E}(\egraph)\) in order to complete \(\egraph\).
			
			Choose any \((\tuple, \tuple') \in \text{V}(\egraph)\).	If \((\relations{\tuple}, \relations{\tuple'}) \in \sgraph{\db}\), then \((\tuple, \tuple')\) is an edge in \(\egraph\).
			
			Recall our earlier assertion that \(\sgraph{\db}\) is cycle-free and foreign keys must be unique.
		\end{proof}
		
		\todo{Above proof could use some love}
		
	\section{Encoding an Entity Group as a Document Group}
	\label{sec:encoding-entity-group-as-document-group}
		Given a entity group \(\egraph\), we construct two or more documents in order to represent the entity group in the document model.
		
		For every \(\tuple \in \text{V}(\egraph)\), we construct a document \(\docs{\tuple}\) (\vref{sec:named-tuples-documents}).  With each tuple \(\tuple\) stored in the document collection \(\dc\), we construct an additional document which stores the association information.
		
		Let \(x\) be the indexing document of \(\egraph\).
		\begin{align}
			x[\text{``entities''}] = \bigcup_{\tuple \in \text{V}\left(\egraph\right)} \uid{\tuple}
		\end{align}
		
		Thus, the encoding of \(\egraph\) is defined as
		\begin{align}
			\egraph \xrightarrow{\text{encode}} \{\docs{\tuple} : \tuple \in \text{V}(\egraph)\} \cup \{x\}
		\end{align}
		
		\begin{ex}
			An entity group produced from the schema in \vref{fig:schema-graph} would be as follows
			
			\begin{figure}
				\centering
				
				\begin{dot2tex}[dot]
					digraph G {
						node [shape=plaintext]; {node [label="Course(MATH 360, Complex Analysis, MATH)"] course;}
						node [shape=plaintext]; {node [label="Subject(MATH, Mathematics)"] subject;}
						
						course -> subject;
					}
				\end{dot2tex}
				
				\caption{Example entity group}
				\label{fig:entity-group}
			\end{figure}
			
			Transforming the example entity group in \vref{fig:entity-group} would produce documents shown in \vref{tbl:document-encoding}
			
			\begin{table}
				\begin{subtable}[b]{0.33\linewidth}
					\centering
					
					\begin{tabular}{ll}
						\toprule
						Field & Terms \\
						\midrule
						code & \(\{\text{math}, \text{360}\}\) \\
						title & \(\{\text{complex}, \text{analysis}\}\) \\
						subject & \(\{\text{math}\}\) \\
						\bottomrule
					\end{tabular}
					
					\caption{Course}
				\end{subtable}
				\begin{subtable}[b]{0.33\linewidth}
					\centering
					
					\begin{tabular}{ll}
						\toprule
						Field & Terms \\
						\midrule
						id & \(\{\text{math}\}\) \\
						name & \(\{\text{mathematics}\}\) \\
						\bottomrule
					\end{tabular}
					
					\caption{Subject}
				\end{subtable}
				\begin{subtable}[b]{0.33\linewidth}
					\centering
					
					\begin{tabular}{ll}
						\toprule
						Field & Terms \\
						\midrule
						entities & \(\{\text{course|math\_360}\), \\
						& \(\text{subject|math}\}\) \\
						\bottomrule
					\end{tabular}
					
					\caption{Indexing document}
				\end{subtable}
				
				\caption{Document encoding of \vref{fig:entity-group}}
				\label{tbl:document-encoding}
			\end{table}
		\end{ex}
		
		It's easy to see that from \(\text{encode}(\egraph)\) we can recover \(\text{V}(\egraph)\), the tuples in \(\egraph\).
		
		By \vref{clm:lossless}, this is sufficient to recover \(\egraph\) entirely.
	
	\section{Encoding Attribute Values into Searchable Documents}
		Each value for user selected attributes are converted into \(n\)-grams, and stored in special documents.
	
	\section{Iterative Search Using Document Encodings}
		A document database supports fast and flexible keyword search queries.	A search query is characterized by \(\q = (\field, \w)\), where \(\field\) is an optional field name, and \(\w\) is a search phrase.
		
		\(\query(\q)\) is the set of documents returned by the text index.  The query function, combined with the extended document model, permits powerful search queries to be issued.  Our implementation supports approximate string matching using \(n\)-grams (\cref{sec:n-gram}) for values, searching for entities containing keywords (see \vref{ex:entity-search}), and the discovery of intermediate entities given two known entities.
		
		\begin{ex}[Entity Search]
		\label{ex:entity-search}
			Find all entities that match the keyword ``math''.
			
			Let \(\q = \text{``math''}\) be the search query.  The results are
			\begin{align*}
				\query(\q) &= \query(\text{``math''}) \\
				&= \{\text{subject|math}, \text{course|math\_360}\}
			\end{align*}
			
			which are coincidentally related.  The results of an entity search query are not necessarily related.
		\end{ex}
		
		\begin{ex}[Entity Graph Search]
			Find the shortest path between the two entities with the unique identities of ``subject|math'' and ``instructor|5''.
			
			\todo{Finish example}
		\end{ex}
		
		
		
		
		
		
		
		
		
		
		
		
		
		