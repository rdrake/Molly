\chapter{Experimental Evaluation}
\label{chap:experimental-evaluation}
	In this chapter we evaluate our implementation of the system for transforming data in the relational model to the document model and vice versa described in \cref{chap:tale-of-two-data-models}.  We detail the implementation details in \cref{sec:implementation}, the methodology and evaluation in \cref{sec:runtime-evaluation}, and provide a number of lessons we learned from evaluating our system in \cref{sec:lessons-learned}.
	
	\section{Implementation}
	\label{sec:implementation}
		The system was implemented in Clojure, which \textcquote{clj-home}{is a dynamic programming language that targets the \gls{jvm}}.  Clojure was chosen due to its rich, immutable, and persistent data structures, excellent concurrency support, and seamless \gls{jvm} interoperability.  These features were discussed in detail in \cref{sec:features-of-clojure}.
		
		\subsection{Code Base Statistics}
			The system consists of over 800 lines of Clojure, along with approximately 550 lines of Python.  The Python code is used to construct the data set by crawling the course information site, as well as to aggregate the benchmark data produced by the system, producing graphs.
			
			All development has occurred on GitHub \cite{molly-repo}. \todo{Expand on this.  Why is GitHub significant?}
	
	\section{The Data Corpus}
	\label{sec:data-corpus}
		The data corpus was derived from the \gls{uoit} mycampus database.  An \gls{html} crawler was written in Python that scraped the information from the \gls{uoit} class schedule search page.  This data was parsed, normalized, then placed in a SQLite database.
		
		The data corpus consists of numerous classes of objects.  These are campuses (\cref{tbl:corpus-campus}), courses (\cref{tbl:corpus-course}), instructors (\cref{tbl:corpus-instructor}), locations (\cref{tbl:corpus-location}), schedules (\cref{tbl:corpus-schedule}), sections (\cref{tbl:corpus-section}), subjects (\cref{tbl:corpus-subject}), and terms (\cref{tbl:corpus-term}).  A graph representation of how these classes of objects are related can be found in \cref{fig:schema-graph}.  The data corpus is defined in \cref{chap:data-corpus-def}
		
		The number of objects, as of the publication of this thesis, can be found in \cref{tbl:data-corpus-count}.
		
		\begin{table}[H]
			\centering
			\begin{tabular}{lr}
			\toprule
			Class & Count \\
			\midrule
			Campus & 8 \\
			Course & 1797 \\
			Instructor & 560 \\
			Location & 220 \\
			Schedule & 20985 \\
			Section & 6211 \\
			Subject & 68 \\
			Term & 32 \\
			\bottomrule
			\end{tabular}
			
			\caption{Number of objects in data corpus, grouped by class}
			\label{tbl:data-corpus-count}
		\end{table}
	
	\section{Runtime Evaluation}
	\label{sec:runtime-evaluation}
		Scripts were written to coordinate the execution, collection, and transformation of the performance data of our implementation.
		
		\subsection{Methodology}
			We used Criterium\footnote{\url{http://hugoduncan.org/criterium/}} to handle the execution of the benchmarks as it handles unique concerns stemming from benchmarking on the \gls{jvm}.  These issues, identified by \citeauthor{rob-java-bench-08} \cite{rob-java-bench-08}, include:
			
			\begin{itemize}
				\item Statistical processing of multiple evaluations
				\item Inclusion of a warm-up period, designed to allow the JIT compiler to optimize its code
				\item Purging of the garbage collector before testing, to isolate timings from GC state prior to testing
				\item A final forced garbage collection after testing to estimate impact of cleanup on the timing results
			\end{itemize}
		
			This requires a much longer runtime as each function must be invoked numerous times.  In extreme cases (Ford-Fulkerson, 8 hops) this can take upwards of 4 hours in our test environment.
			
			During evaluation, Criterium collects performance metrics.  Upon completion of the evaluation, it performs statistical analysis of these metrics using the bootstrap procedure developed by \citeauthor{efron-87} \cite{efron-87}.  These metrics include mean, samples, variance, quartiles, outliers, and more.
		
			\subsubsection{Data Collection}
			\label{sec:data-collection}
				The performance metrics computed by Criterium are returned as a Clojure map data structure.  The evaluation process may take several hours to complete, necessitating a separation between data collection and post-processing.  These metrics are stored offline for further processing.
				
				In order to utilize the Clojure output in Python, a data interchange format (\gls{json}) is used.  The benchmark function writes the Criterium performance analysis out as a \gls{json} string to stdout and the output is captured by the benchmark script.  An example of this \gls{json} output is given in \cref{fig:criterium-json-output}.
				
				\begin{figure}[H]
					\centering % Pointless, but who knows in the future.
					\begin{verbatim}
[
    {
        "max-hops": ...,
        "method": ...,
        "results": {
            "execution-count": ...,
            "final-gc-time": ...,
            "lower-q": [...],
            "mean": [...],
        ...
    }, ...
]
					\end{verbatim}
					
					\caption{Partial \gls{json} output from Criterium.}
					\label{fig:criterium-json-output}
				\end{figure}
		
		\subsection{Performance}
			\input{figures/charts/lineplot-tkv-50-tkes-25-tke-5.pgf}
			\input{figures/charts/lineplot-tkv-50-tkes-5-tke-5.pgf}
		
		\begin{itemize}
			\item Index speed
			\item Keyword search speed
			\item Graph search speed:
				\begin{itemize}
					\item Ford Fulkerson
					\item BFS
					\item Concurrent BFS using refs
					\item Concurrent BFS using atoms
				\end{itemize}
		\end{itemize}
	
	\section{Lessons learned}
	\label{sec:lessons-learned}
		\begin{itemize}
			\item Simple algorithms are easier to parallelize
			\item STM is effective: transactions do not rollback (that much), so we observe impressive speed-up in concurrent versions.
			\item Fine tuning is beneficial: atom is better than ref.
			\item The clojure way: correctness first, runtime optimization latter (ref to atom is natural).
		\end{itemize}