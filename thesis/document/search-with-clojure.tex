\section{Search With Clojure}
	Clojure's excellent \gls{jvm} interoperability permits the use of countless third-party libraries.  The most extensively used was Lucene.
	
	\subsection{Full-Text Search Using Lucene}
		\textcquote{luc-home}{Apache Lucene\texttrademark\ is a high-performance, full-featured text search engine library written entirely in Java.}
	
	\subsection{Indexing Relational Database}
		The process of indexing a relational database is a multi-step one.  It begins with the declaration of the database connection information, the path to the index, and the schema definition.
		
		In our implementation, this information is specified by a record that adheres to the protocol in \vref{clj:iconfig}.  The record which defines the Mycampus dataset uses SQLite for its database engine, so it accepts two strings; one specifies the path to the database file, while the other specifies the path to the index.
		
		\begin{figure}
			\begin{singlespaced}
				\begin{pygments}[firstnumber=16]{clj}
(defprotocol IConfig
  (connection [this])
  (schema [this])
  (index [this]))
				\end{pygments}
			\end{singlespaced}
			
			\caption{\texttt{IConfig} protocol all configurations must adhere to}
			\label{clj:iconfig}
		\end{figure}
		
		The first component, \texttt{connection}, returns a \gls{jdbc}-compatible object.  The second component, \texttt{schema}, returns a list of \texttt{EntitySchema} records.  The \texttt{EntitySchema} record is defined in \vref{sec:entity-schema}.  The final component, \texttt{index}, specifies the path to the index.
		
		\subsubsection{Schema Graph Definition}
		\label{sec:entity-schema}
			The schema graph is defined using Korma, which \textcquote{clj-korma}{is a \gls{dsl} for Clojure}.  Each schema component, whether an entity or entity group, is defined by \texttt{EntitySchema} records.  Each record accepts a map which specifies how each class of document should be indexed and identified.  The keys of this map are given in \vref{tbl:entity-schema-keys}.
			
			\begin{table}
				\centering
				
				\begin{tabular}{lp{9cm}l}
					\toprule
					Key & Description & Type(s) \\
					\midrule
					\texttt{:T} & Entity (\texttt{:entity}) or entity group (\texttt{:entity}) & Symbol \\
					\texttt{:C} & Table name for entities, brief description for entity groups & Symbol or String \\
					\texttt{:sql} & \Gls{sql} query used to construct the entity or entity schema & Expression \\
					\texttt{:ID} & Attribute or attributes that comprise the key (\vref{def:keys}) & Symbol or list of symbols \\
					\texttt{:attrs} & List of attributes to analyze to fields & List of symbols \\
					\texttt{:values} & List of attributes to index as values, must be subset of \texttt{:attrs} & List of symbols \\
					\bottomrule
				\end{tabular}
				
				\caption{Keys expected by \texttt{EntitySchema} records}
				\label{tbl:entity-schema-keys}
			\end{table}
			
			The \texttt{EntitySchema} records contain not only the information required to construct them, but also the required behaviour.  Every record, given the database and index connections, is capable of retrieving the set of all named tuples it represents in the database.  It iterates through every tuple and constructs a document for each tuple, as well as any value documents, if applicable.
			
		\subsubsection{Indexing Process}
			With the database, index, and schema graph defined, the system is able to transform the data from the relational model into the document model.
			
			The first step is to retrieve the list of named tuples from the database.  Each \texttt{EntitySchema} record is iterated over; the \gls{sql} defined for each record is executed against the database.  A function is executed on every tuple that is retrieved.
			
			The second step is to transform these tuples into the internal representation.  The function executed on every tuple is responsible for this conversion.
			
			The third step is to convert the internal representation into a document.  Again this is performed by the function operating on every tuple.
			
			Finally, every document is indexed.
			
			\begin{table}
				\begin{subtable}[b]{0.33\linewidth}
					\centering
					
					\begin{tabular}{p{1.5cm}p{2.5cm}}
						\toprule
						Attribute & Value \\
						\midrule
						code & CDPS 101 \\
						title & Human-Mutant Relations \\
						subject & CDPS \\
						\bottomrule
					\end{tabular}
					
					\caption{Tuple}
				\end{subtable}
				\begin{subtable}[b]{0.33\linewidth}
					\centering
					
					\begin{tabular}{p{1.5cm}p{2.5cm}}
						\toprule
						Key & Value \\
						\midrule
						\texttt{:type} & \texttt{:entity} \\
						\texttt{:class} & \texttt{:course} \\
						\texttt{:id} & \texttt{``course|cdps\_101''} \\
						\texttt{:code} & \texttt{``CDPS 101''} \\
						\texttt{:title} & \texttt{``Human-Mutant Relations''} \\
						\texttt{:subject} & \texttt{``CDPS''} \\
						\bottomrule
					\end{tabular}
					
					\caption{Internal Representation}
				\end{subtable}
				\begin{subtable}[b]{0.33\linewidth}
					\centering
					
					\begin{tabular}{p{1.5cm}p{2.5cm}}
						\toprule
						Field & Terms \\
						\midrule
						\_\_type\_\_ & :entity \\
						\_\_class\_\_ & :course \\
						\_\_id\_\_ & course|cdps\_101 \\
						\_\_all\_\_ & ``cdps 101 human mutant relations cdps'' \\
						code & \(\{\text{cdps}, \text{101}\}\) \\
						title & \(\{\)human, mutant, relations\(\}\) \\
						subject & \(\{\text{cdps}\}\) \\
						\bottomrule
					\end{tabular}
					
					\caption{Document}
				\end{subtable}
				
				\caption{Transformation from tuple to internal representation to document}
				\label{tbl:tuple-to-document}
			\end{table}
			
	\subsection{Indexing of relational objects (5 days, week 5)}
		\begin{itemize}
			\item Fuzzy indexing of values (typed by classes)
		\end{itemize}

	\subsection{Keyword Search in document space (5 days, week 6)}
		\begin{itemize}
			\item Disambiguate keywords using fuzzy search (suggestion, overloaded terms)
			\item Flexibility keyword search for documents
			\item Translate search result back to relational space
		\end{itemize}

	\subsection{Graph Search in document space (5 days, week 7)}
		\begin{itemize}
			\item Why we need graph search
			\item Search in document graph using graph search algorithms with functional implementations: (Ford Fulkerson, BFS)
			\item Speed up using concurrency
			\item Clojure specific optimization: ref + atom
		\end{itemize}