% !TEX root = Thesis.tex
\documentclass[grad]{uoit-thesis}

\input{preamble.tex}

\degree{Master of Science (M.Sc.)}
\faculty{Science}
\department{Computer Science}
\gradmonth{December}
\gradyear{2013}
\supervisor{Dr. Ken Q. Pu}
\author{Richard J.I. Drake}
\title{Towards a Concurrent Implementation of Keyword Search Over Relational Databases}

\begin{document}
	% Automatically switches to Roman numerals
	\begin{preliminary}
		\maketitle

		% Title page is i, certificate of approval is ii, TOC is page...
		\setcounter{page}{3}

		\tableofcontents

		\listoftables
		\listoffigures
		\listofalgorithms
		\printnomenclature
	\end{preliminary}
	
	\chapter{Background (2 days)}
		Literature search on:

		\begin{itemize}
			\item DBExplore
			\item XRank
			\item BANKS
			\item ...
		\end{itemize}
	
	\input{data-model}
	
	\chapter{Along came Clojure}
		\section{Basic principles of functional programming (2 days)}
			\begin{itemize}
				\item immutable data structures
				\item persistent data structures using multi-versioning
				\item functions (and higher order functions) as values
			\end{itemize}
		
		\section{Features of Clojure (2 days)}
			\begin{itemize}
				\item Data structures supporting the universal design pattern
				\item Concurrency + STM
				\item Interoperability with JVM (including Lucene)
			\end{itemize}

	\chapter{Search w/ Clojure}
		\section{Thirdparty libraries (1 day, week 4)}
			\begin{itemize}
				\item Lucene
			\end{itemize}

		\section{Indexing of relational objects (5 days, week 5)}
			\begin{itemize}
				\item Schema definition
				\item Crawling using SQL
				\item Indexing using relational objects
				\item Fuzzy indexing of values (typed by classes)
			\end{itemize}

		\section{Keyword Search in document space (5 days, week 6)}
			\begin{itemize}
				\item Disambiguate keywords using fuzzy search (suggestion, overloaded terms)
				\item Flexibility keyword search for documents
				\item Translate search result back to relational space
			\end{itemize}

		\section{Graph Search in document space (5 days, week 7)}
			\begin{itemize}
				\item Why we need graph search
				\item Search in document graph using graph search algorithms with functional implementations: (Ford Fulkerson, BFS)
				\item Speed up using concurrency
				\item Clojure specific optimization: ref + atom
			\end{itemize}

	\chapter{Experimental evaluation (5 days, week 8)}
		\section{Implementation}
			\begin{itemize}
				\item Choice of language
				\item Statistics about the code base: LOC, classes, ?
				\item Github hosted
			\end{itemize}

		\section{The data set}
			\begin{itemize}
				\item Description of the data set
				\item Statistics of the data set
			\end{itemize}

		\section{Runtime Evaluation}
			\begin{itemize}
				\item Index speed
				\item Keyword search speed
				\item Graph search speed:
					\begin{itemize}
						\item Ford Fulkerson
						\item BFS
						\item Concurrent BFS using refs
						\item Concurrent BFS using atoms
					\end{itemize}
			\end{itemize}

		\section{Lessons learned}
			\begin{itemize}
				\item Simple algorithms are easier to parallelize
				\item STM is effective: transactions do not rollback (that much), so we observe impressive speed-up in concurrent versions.
				\item Fine tuning is beneficial: atom is better than ref.
				\item The clojure way: correctness first, runtime optimization latter (ref to atom is natural).
			\end{itemize}

			\chapter{Conclusion (0 days)}
				Survived Clojure.

	\appendix
	
	%\begin{singlespaced}
	%	\input{source-code.tex}
	%\end{singlespaced}
	
	\printbibliography
	
	\todos
\end{document}
