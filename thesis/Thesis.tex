% Change "draft" to "final" when you're done.
\documentclass[12pt,letterpaper,oneside,draft]{report}

\usepackage[top=1in,left=1.5in,right=1in,bottom=1in]{geometry}

\usepackage{fontspec,lipsum}
\usepackage{mathpazo}
\defaultfontfeatures{Ligatures=TeX}
\usepackage[small,sf,bf]{titlesec}

\usepackage{xltxtra}
\usepackage{xunicode}

%\DisemulatePackage{setspace}
\usepackage{setspace}
%\onehalfspacing
\doublespacing

\usepackage{titling}

\usepackage{unicode-math}
\usepackage{amsmath}
\usepackage{amsthm}

\usepackage{algorithm}
\usepackage{algorithmic}

%\usepackage{minted}
\usepackage{tikz}

\usepackage{booktabs}

\usepackage{nag}

\setmainfont[
	Numbers=OldStyle,
	Kerning=Uppercase,
	SizeFeatures={
		{Size={8-10}, Font=* Caption},
		{Size={10.01-}, Font=*}
	}]{Garamond Premier Pro}
\setsansfont{Futura Std}
\setmathfont{STIXGeneral}
\setmonofont{Consolas}

\pagenumbering{roman}

\newcommand{\thesistitle}[8]{
	\title{#1}
	\author{#2}

	\begin{titlepage}
		\centering
		\vspace{2cm}
			{\huge\sc #1}\\[1cm]

			by\\[1cm]

			{\Large #2}\\[2cm]

			\singlespacing{A Thesis Submitted in Partial Fulfillment\\of the Requirements for the Degree of}\\[1cm]

			#3\\[0.5cm]

			in\\[0.5cm]

			Faculty of #4\\[0.5cm]

			#5\\[1.5cm]

			University of Ontario Institute of Technology\\[1.5cm]

			Supervisor:  #6\\[1.5cm]

			#7 #8\\[3cm]

			Copyright \copyright\ #2 #8
	\end{titlepage}}

\theoremstyle{definition}
\newtheorem{defn}{Definition}

\begin{document}
	\thesistitle{Molly}{Richard Drake}{Masters of Science}{Science}{Computer Science}{Dr. Ken Q. Pu}{September}{2012}

	\begin{abstract}
		\lipsum[2]
	\end{abstract}

%	\begin{acknowledgements}
%		\lipsum[2]
%	\end{acknowledgements}

	\chapter*{Preface}
		\section*{Background and Motivation}
			The introduction of keyword search has revolutionized how we find information.  Over the years, numerous techniques have been developed which make searching through large amounts of information for one or more keywords extremely fast.  With the advent of faster computer hardware, we are able to not only search through small attributes of a document (eg. Title, synopsis, etc.) but rather the entirety of the document itself.
		
			An example of an early system which utilized keyword search would be a library catalogue.  Such a system would allow a user to search, by keyword, for the title of a book, manuscript, etc.  The results would show item titles matching the keyword(s), as well as other information such as whether or not the item is in circulation, as well as where it is located within the library.  This information would come from a relational database.
		
			With the rise of the World Wide Web, much information was placed online.  This information would be easy to access if one knew how to locate it.  Unfortunately, over time, so much information existed on the World Wide Web that it became difficult to keep track of it all.  There was a need to index all of this information and make it accessible.  This need was filled by a Web search engine.
		
			Initial Web search engines comprised of simple scripts that gathered listings of files on FTP servers; they were essentially link farms.  A few short years later, the first full-text (keyword) search engine, WebCrawler, was released.
		
			While full-text search engines provided an excellent means for locating information, as the Web grew larger, the volume of noise also grew larger.  In addition, every Web page could be structured in a different way; the Web was largely a collection of unstructured documents.  That is, there were few obvious links between them.
		
			Search engines such as Google attempted to solve this problem by introducing new algorithms, such as PageRank, to rank Web pages on both the relevance of their content as well as their reputation.  The idea was if a page is linked to often, it is considered to be more authoritative on a subject than a page with fewer links.  This allowed the relevance of a page to be computed based on not only its contents, but its artificial importance.
		
			Molly attempts to avoid some of the issues plaguing search engines.  It deals primarily with structured, filtered data.  This allows us to provide results with less noise.  In addition, the fact that it deals with structured data means links between documents are explicitly stated.  Rather than inferring a link between documents based on hyperlinks, we know when two documents are linked together.
		
			This thesis provides an overview of the Molly system.
		
		\section*{Outline}
			Changed.

	\tableofcontents

	\listoftables
	\listoffigures
	\listofalgorithms

	\clearpage
	\pagenumbering{arabic}

	\chapter{Literature Review}
	
	\chapter{Theoretical}
		Problem definition
		
		\section{Data Representation \& Notation}
			Formal definition data model
		
		\section{Relational Database Abstraction}
			Value -> entity -> graph abstract of a relational database
		Connected subgraph from keyword queries
		
		\section{Data Corpus}
			For illustrative purposes, the mycampus dataset will be used.  This data comes from UOIT's course registration system.
			
			There are several different entities which comprise the mycampus dataset:
			
			\begin{itemize}
				\item Courses
				\item Instructors
				\item Schedules
				\item Sections
				\item Teaches
			\end{itemize}
			
			The \textbf{Courses} entity represents a course.  A course has an individual code, along with a title and a description (See Table  \ref{tbl:courses-entity-schema}).  The code uniquely identifies the course.
			
			\begin{table}[!htp]
				\centering
				\begin{tabular}{lll}
					\toprule
					Column & Type & Description \\
					\midrule
					code & VARCHAR & Unique course code \\
					title & VARCHAR & Title of the course \\
					description & TEXT & A brief description \\
					\bottomrule
				\end{tabular}
				\caption{Courses entity schema}
				\label{tbl:courses-entity-schema}
			\end{table}
			
			The \textbf{Instructors} entity represents an individual instructor.  Each instructor has a unique identifier, as well as a name (See Table \ref{tbl:instructors-entity-schema}).  An instructor can be a Professor, Lecturer, Sessional Instructor, or Teaching Assistant.
			
			\begin{table}[!htp]
				\centering
				\begin{tabular}{lll}
					\toprule
					Column & Type & Description \\
					\midrule
					id & INT & Unique identifier \\
					name & VARCHAR & The instructor's name \\
					\bottomrule
				\end{tabular}
				\caption{Instructors entity schema}
				\label{tbl:instructors-entity-schema}
			\end{table}
			
			The \textbf{Sections} entity represents a section of a course.  Courses may have many sections.  For example, one section could be a lecture, while another is a lab.  Some courses may have over a dozen sections, depending on the associated term.
			
			Each section contains a unique identifier, capacity information (students enrolled, spots open, etc.), when registration is open for the section, how many credits it is worth, what level (eg. undergraduate or graduate), and what year the section is offered in (See Table \ref{tbl:sections-entity-schema}).
			
			\begin{table}[!htp]
				\centering
				\begin{tabular}{lll}
					\toprule
					Column & Type & Description \\
					\midrule
					id & INT & Unique identifier \\
					actual & INT & Number of people enrolled in the course \\
					campus & VARCHAR & String uniquely identifying the campus \\
					capacity & INT & Maximum number of people that may be enrolled in the section \\
					credits & FLOAT & Number of credits awarded upon successful completion \\
					levels & VARCHAR & The level of the course (eg. undergraduate, graduate, etc.) \\
					registration\_start & DATE & Date registration for the section opens \\
					registration\_end & DATE & Date registration for the section ends \\
					semester & VARCHAR & String that uniquely identifies the semester \\
					sec\_code & INT & Unique section code (called a CRN) \\
					sec\_number & INT & Sequential number identifying the number of the section \\
					year & INT & The year the section is offered in \\
					\bottomrule
				\end{tabular}
				\caption{Sections entity schema}
				\label{tbl:sections-entity-schema}
			\end{table}
			
			The \textbf{Schedules} entity represents a scheduled meeting of a section.  A section may have many schedules.  For example, a lecture section may meet twice a week.
			
			Each schedule has a unique identifier, a date range in which the schedule is active, the time of the schedule, the type, location, and the day which the class takes place (See Table \ref{tbl:schedules-entity-schema}).
			
			\begin{table}[!htp]
				\centering
				\begin{tabular}{lll}
					\toprule
					Column & Type & Description \\
					\midrule
					id & INT & Unique identifier \\
					date\_start & DATE & First day of class \\
					date\_end & DATE & Last day of class \\
					day & VARCHAR & Single character representing the day of the week \\
					schedtype & VARCHAR & Lecture, tutorial, lab, etc. \\
					hour\_start & INT & Hour the class starts at \\
					hour\_end & INT & Hour the class ends at \\
					min\_start & INT & Minute the class starts at \\
					min\_end & INT & Minute the class ends at \\
					classtype & VARCHAR & The type of class \\
					location & VARCHAR & Unique location name where class is held \\
					\bottomrule
				\end{tabular}
				\caption{Schedules entity schema}
				\label{tbl:schedules-entity-schema}
			\end{table}
			
			A \textbf{Teaches} entity is used to link together an instructor and a schedule.  Each link has a unique identifier along with the instructor's position (eg. Teaching Assistant, Lecturer, etc.) (See Table \ref{tbl:teaches-entity-schema}).
			
			\begin{table}[!htp]
				\centering
				\begin{tabular}{lll}
					\toprule
					Column & Type & Description \\
					\midrule
					id & INT & Unique identifier \\
					position & VARCHAR & Position of the Instructor with regard to a Schedule \\
					\bottomrule
				\end{tabular}
				\caption{Teaches entity schema}
				\label{tbl:teaches-entity-schema}
			\end{table}
		
		\section{Graph Search Algorithms}
			Careful consideration was given to which graph search algorithm was to be used.  Among the choices were:
			
			\begin{itemize}
				\item Breadth-First
				\item Bellman-Ford
				\item Dijkstra
				\item A*
			\end{itemize}
			
			The first choice, Breadth-First Search, is among the simplest of the algorithms.  It has the advantage of being simple to implement.  It can only handle fixed costs for travelling between nodes, which can be a disadvantage.
			
			Bellman-Ford is similar to BFS.  It has the ability to deal with variable cost.  This comes at the cost of increased difficulty in implementation.  When the cost between nodes is fixed, Bellman-Ford essentially becomes BFS.
			
			A greedy version of BFS is Dijkstra's Algorithm.  It utilizes a priority queue rather than a regular queue, allowing it to be faster.  As it is a greedy algorithm, Dijkstra's Algorithm may not return the optimal result.
			
			An extension to Dijkstra's is A* search.  Graph search spaces can be rather large.  A* attempts to prune the search space based on a heuristic.  A* is a natural choice to perform graph search in certain areas such as computer vision where an obvious heuristic exists.  It has a disadvantage of consuming large amounts of memory (though IDA* attempts to limit memory consumption).
			
			There are many more graph search algorithms.  The above were primarily considered as many of the other algorithms are simple extensions with different data structures.
			
			For this application, there is no obvious heuristic.  This eliminates A*.  There is also no obvious cost function.  This eliminiates Dijkstra's Algorithm.  Bellman-Ford is very similar to BFS with the added ability to deal with variable cost.  As the cost function is not obvious and thus constant, Bellman-Ford essentially reverts back to BFS.
			
			For these reasons, BFS was chosen as the graph search algorithm.  While the other candidates and others provide numerous advantages over BFS in many situations, this is not one of them.
	
	\chapter{Implementation}
		\section{Functional vs. Procedurial Programming of Algorithms}
			Key differences between FP and procedurial (for algorithms)
			
			\subsection{Functional Data Structures}
				Clojure immutable data structures, versioning (persistent data structures), STM vs. locking
			
		\section{Tunable Parameters}
			Tunable parameters
	
	\chapter{System Implementation}
		\section{Technology Selection}
			\subsection{Programming Language}
			
			\subsection{Relational Database}
			
			\subsection{Full-Text Search Database}
			
			\subsection{Web Stack}
		
		\section{Implementation Issues}
	
	\chapter{Performance \& Evaluation}
		Screenshots?
		Graphs
		Experiments
	
	\chapter{Conclusion}
	
\end{document}
